local LootEvents = require "lootevents"
local monsterutil = require "util.monsterutil"
local lume = require"util.lume"
-- This is a component added to mob enemies that spawns the actual loot
-- data generated by data from LootDropManager
local LootDropper = Class(function(self, inst)
	self.inst = inst
	self.fixedloot = {}
	self.chanceloot = {}
	self.weightedchancelists = {}
	self.weightedpicklists = {}

	self.loot_dropper_value = 0.6
	self.loot_drop_tags = {}

	self.loot_to_drop = {} -- k:ownerGUID, v:table (k:string (drop prefix), v: count)
	self.lucky_loot = {} -- same as loot_to_drop
	self.hasLootGenerated = false
	self.hasLootDropped = false
	self.konjurRewardProcessed = false

	if self.inst.tuning then
		self:SetLootDropperValue(self.inst.tuning.loot_value)
	end
end)

function LootDropper:OnPostSpawn()
	monsterutil.BuildDropTable(self.inst)
end

function LootDropper:HasDropped()
	return self.hasLootDropped
end

function LootDropper:OnDeath()
	-- TheLog.ch.Networking:printf("LootDropper:OnDeath")
	local hasAddedLoot = false
	if not self.hasLootGenerated then
		self.hasLootGenerated = true
		for _, player in ipairs(AllPlayers) do
			if player:IsLocal() then
				-- this call has side effects into self.loot_to_drop, self.lucky_loot
				-- this call has side effects into player.components.lootdropmanager
				hasAddedLoot = player.components.lootdropmanager:OnLootDropperDeath(self.inst) or hasAddedLoot
			end
		end
	end

	-- Send the loot generated for these local players to remote clients so they can process
	-- the drop and generate their own loot.
	-- Local players will see the generated data processed on the entity's death via DropLoot()
	if hasAddedLoot then
		LootEvents.MakeEventGenerateLoot(self.inst, self.loot_to_drop, self.lucky_loot)
	end	
end

function LootDropper:OnDeathKonjur()
	if not self.konjurRewardProcessed then
		self.konjurRewardProcessed = true
		LootEvents.MakeEventRequestSpawnCurrency(self.inst)
	end
end

function LootDropper:AddLootToDrop(owner, loot)
	if self.loot_to_drop[owner] then
		self.loot_to_drop[owner] = lume.merge(self.loot_to_drop[owner], loot)
	else
		self.loot_to_drop[owner] = loot
	end
end

function LootDropper:AddLuckyLoot(owner, loot)
	if self.lucky_loot[owner] then
		self.lucky_loot[owner] = lume.merge(self.lucky_loot[owner], loot)
	else
		self.lucky_loot[owner] = loot
	end
end

function LootDropper:DropLoot()
	if not self.hasLootDropped then
		self.hasLootDropped = true
		LootEvents.HandleEventDropLoot(self.inst, self.loot_to_drop, self.lucky_loot)
	end
end

function LootDropper:AddLootDropTags(tags)
	-- add a table of tags. this will allow items that contain all of the tags in the table to drop.
	-- for example, if you add a table that has {'drops_cabbageroll', 'drops_common'} the dropper can only drop an item that has both of those tags.
	-- but if you add a table that just has {'drops_cabbageroll'} the dropper will be able to drop any item that has the 'drops_cabbageroll' tag, regardless of other tags the item might have.
	table.insert(self.loot_drop_tags, tags)
end

function LootDropper:OnRemoveFromEntity()
	self.inst:RemoveEventCallback("death", self._on_death)
end

function LootDropper:SetLootDropperValue(val)
	assert(val, self.inst.prefab)
	self.loot_dropper_value = val
end

function LootDropper:GetLootDropperValue()
	return self.loot_dropper_value
end

-- Guaranteed loot
function LootDropper:AddFixedLoot(prefab, min, max)
	self.fixedloot[#self.fixedloot + 1] = { prefab = prefab, min = min, max = max }
end

-- Chance to drop each individual loot
function LootDropper:AddChanceLoot(prefab, chance)
	assert(0 <= chance and chance <= 1)
	self.chanceloot[#self.chanceloot + 1] = { prefab = prefab, chance = chance }
end

-- Picks specified amount from each weighted list
-- Chosen items are NOT removed after each pick.
-- list should be a WeightedList.
function LootDropper:AddWeightedChanceList(list, min, max)
	self.weightedchancelists[#self.weightedchancelists + 1] = { list = list, min = min, max = max }
end

-- Picks specified amount from each weighted list
-- Chosen items are REMOVED after each picked.
-- list should be a WeightedList.
function LootDropper:AddWeightedPickList(list, min, max)
	self.weightedpicklists[#self.weightedpicklists + 1] = { list = list, min = min, max = max }
end

function LootDropper:GenerateLoot()
	local ret = {}

	--Fixed loot
	for i = 1, #self.fixedloot do
		local v = self.fixedloot[i]
		local num = math.random(v.min or 1, v.max or v.min or 1)
		for j = 1, num do
			ret[#ret + 1] = v.prefab
		end
	end

	--Chance loot
	for i = 1, #self.chanceloot do
		local v = self.chanceloot[i]
		if math.random() < v.chance then
			ret[#ret + 1] = v.prefab
		end
	end

	--Weighted chance loot lists
	for i = 1, #self.weightedchancelists do
		local v = self.weightedchancelists[i]
		local num = math.random(v.min or 1, v.max or v.min or 1)
		for j = 1, num do
			ret[#ret + 1] = v.list:PickItem()
		end
	end

	--Weighted pick loot lists
	for i = 1, #self.weightedpicklists do
		local v = self.weightedpicklists[i]
		local num = math.random(v.min or 1, v.max or v.min or 1)
		local list = v.list:Clone()
		for j = 1, num do
			ret[#ret + 1] = list:PickAndRemoveItem()
		end
	end

	return ret
end

return LootDropper
